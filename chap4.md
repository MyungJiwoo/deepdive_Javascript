## 4.1 변수랑 무엇인가? 왜 필요한가?

-   연산자를 기준으로 좌변과 우변은 피연산자
-   컴퓨터는 2진수로 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억
    -   이때 메모리는 데이터를 저장할 수 있는 메모리 셀(memory cell)의 집합체
    -   메모리 셀 == 1 byte == 8 bit
-   메모리 셀 단위로 (즉, 1byte 단위로 데이터를 저장하거나 읽음)
-   각 셀은 고유의 메모리 주소를(memory address) 가짐 ⇒ 메모리 공간의 위치 (0~메모리 크기만큼 정수)
-   연산 과정
    1. 피연산자를 메모리 상의 임의의 위치에 저장
    2. CPU가 이 값을 읽어 연산 실행 (재사용 X)
    3. 결과 값을 메모리의 임의의 위치에 저장
       ⇒ 메모리에 저장되는 모든 숫자는 2진수로 처리
-   연산 값이 저장되는 메모리 주소는 랜덤으로 정해지며, 메모리 주소를 통해 값에 직접 접근 할 수 없음
    ⇒ 한개의 값을 저장하려 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하려 붙인 이름 == `변수`
    ⇒ 변수 안에 저장된 값 == `변수 값`
-   변수 이름을 참조해 요청하면, 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에
    접근하여 저장된 값을 반환
-   변수에 여러 개의 값을 저장하려면, 배열이나 객체와 같은 자료구조를 활용함

## 4.2 식별자 (identifier)

-   식별자
    -   어떤 값을 구별해서 식별할 수 있는 고유한 이름
    -   즉, 메모리 주소에 붙인 이름
    -   변수, 함수, 클래스 등 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자
-   값은 메모리 공간에 저장되어 있고, 식별자는 어떤 값이 저장되어 있는 `메모리 주소`를 저장해야 함
-   네이밍 규칙 준수
-   선언(declaration)에 의해 자바스크립트 엔진에 식별자의 존재를 알림

## 4.3 변수 선언

-   값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)
-   메모리 공간 해제가(release) 될 때까지는 보호되므로 안전하게 사용 가능
-   `var`, `let`, `const` 키워드를 사용해 변수 선언

    -   var의 단점
        -   블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원
              <aside>
              💡 **블록 레벨 스코프 (block-level scope)**
              모든 코드 블록내에서 선언된 변수는 코드 블록 내에서만 유효, 블록 외부에선 참조 불가
              
              </aside>
              
              <aside>
              💡 **함수 레벨 스코프 (function-level scope)**
              함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조 불가
              함수의 코드 블록만 스코프로 인정
              전역 함수 외부에서 생성한 변수는 모두 전역 변수
              
              </aside>
              
              <aside>
              💡 **키워드 (keyword)**
              js 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어
              
              </aside>

-   변수 선언 예제

    ```jsx
    var score;
    ```

    -   이렇게 변수 선언을 하면 값에는 아무 것도 없을 것 같지만, 사실 기본 값으로 `undefined` 할당
          <aside>
          💡 **undefined Type**
          자바스크립트에서 제공하는 원시 타입의 값(orimitive value)
          
          </aside>

-   변수 선언의 2단계

    1. 선언 : 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재 알림
    2. 초기화 : 메모리 공간을 확보하고 undefined 할당 (최초로 값을 할당하는 것)

        ⇒ 만약 초기화 단계를 거치지 않으면, 이전에 사용한 값이 남아있을 수 있음을 방지

-   변수 이름이 등록되는 공간

    -   실행 컨텍스트에 등록
    <aside>
    💡 **실행 컨텍스트(exeuction context)**
    자바스크립트 엔진이 코드를 평가, 실행하기 위한 환경을 제공
    코드의 실행 결과를 실제로 관리하는 영역
    식별자와 스코프 관리
    key-value 쌍으로 저장

      </aside>

-   선언하지 않은 식별자에 접근
    -   ReferenceError(참조 에러) 발생
    <aside>
    💡 **ReferenceError**
    식별자를 통해 값을 참조하려 했지만, 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생
      </aside>

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

-   자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차 실행
-   하지만, 변수 선언은 런타임 이전의 단계에서 미리 실행됨
    ⇒ 따라서 코드상으로 선언되지 않은 변수를 미리 출력해도 오류가 나지 않음
    -   자바스크립트 엔진은 코드의 모든 선언문을 먼저 소스코드에서 찾아내 실행,
        소스코드의 평가 과정이 끝나면 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행
    -   즉, 선언문의 위치는 어디여도 상관 없음

<aside>
💡 **변수 호이스팅 (variable hoisting)**

변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

</aside>

## 4.5 값의 할당

-   값을 할당할 때는 할당 연산자 `=` 사용
    -   할당 연산자는 우변의 값을 좌변의 변수에 할당
-   사용 예시

    ```jsx
    // 선언
    var score;
    // 초기화
    score = 100;

    // 축약형
    var score = 100;
    ```

    -   축약형으로 변수를 선언하더라도, 변수 선언은 런타임 이전에 실행되고, 값의 할당은 런타임때 이뤄짐
    -   `score = 100;`은 기본 할당인 `undefined`에서 다시 100으로 할당되어, 재할당이라 할 수 있음
        ⇒ 즉, 축약해도 선언과 초기화의 과정은 나눠 실행되며, 변수에 처음으로 `undefined`가 할당되는 것은 동일
        ⇒ 단, 재할당할 때, 기존의 공간에 덮어쓰기 되는 것이 아니라, 새로운 메모리 공간에 값을 할당 받음

## 4.6 값의 재할당

-   재할당
    -   이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것
-   상수는 한번 할당된 값을 변경할 수 없음 (즉, 변하지 않는 값)
    ⇒ `const` 키워드로 상수 할당
-   재할당은 이전의 공간에 새로운 값을 덮어쓰기 하지 않고, 새로운 메모리에 값을 넣어 할당 받음
-   이렇게 생성된 참조를 잃은 값은 가비지 콜렉트에 의해 메모리에서 자동 해제됨
    -   단, 메모리에서 언제 해제 되는지는 예측할 수 없음
    <aside>
    💡 **가비지 콜렉터 (garbage collecter)**
    애플리케이션이 할당한 메모리 공간을 주기적으로 검사하며 더 이상 사용되지 않는 공간을 해제
    메모리 누수(mermory leak) 방지
      </aside>
      
      <aside>
      💡 **언매니지드 언어 (unmanaged language)**
      개발자가 주도하여 명시적으로 메모리 할당 및 해제
      저수준(low-level) 메모리 제어 기능 제공
      개발자의 역량에 따라 득이될 수도, 실이될 수도
      
      </aside>
      
      <aside>
      💡 **매니지드 언어 (managed language)**
      메모리 관리 기능을 언어 차원에서 담당하여 개발자의 직접적 개입을 허용하지 않음
      가비지 콜렉터가 메모리 관리 기능을 담당
      일정한 생산량을 확보할 수 있으나, 성능 면에서 어느 정도의 손실은 감수해야 함
      
      </aside>

## 4.7 식별자 네이밍 규칙

1. 문자(알파벳), 숫자, 언더스코어(\_), 달러($)만 포함
    - 대/소문자 구분
2. 숫자로 시작할 수 없음
3. 키워드를 사용할 수 없음
    - await, break, case, catch, class, const …

-   쉼표(,)를 사용해 한 줄에 여러 변수를 선언할 수 있으나, 가독성의 이유로 바람직하지 않음
-   네이밍 컨벤션(naming convention)
    -   하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위한 규칙
    1. camelCase
        - 변수, 함수 선언
    2. snake_case
    3. PascalCase
        - 생성자 함수와 클래스 선언
    4. typeHungarianCase
        - type + 식별자의 형태로 선언
